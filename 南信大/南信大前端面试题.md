# 初级

## CSS

### box-sizing

CSS 中的 box-sizing 属性定义了引擎应该如何计算一个元素的总宽度和总高度

语法：

```css
box-sizing: content-box|border-box|inherit:
```

- content-box 默认值，元素的 width/height 不包含padding，border，与标准盒子模型表现一致
- border-box 元素的 width/height 包含 padding，border，与怪异盒子模型表现一致
- inherit 指定 box-sizing 属性的值，应该从父元素继承

> 设置盒子为 border-box 模型

```css
<style>
  .box {
    width: 200px;
    height: 100px;
    padding: 20px;
    box-sizing: border-box;
  }
</style>
<div class="box">
  盒子模型
</div>
```

这时候，就可以发现盒子的所占据的宽度为200px



### 选择器

关于`css`属性选择器常用的有：

- id选择器（#box），选择id为box的元素
- 类选择器（.one），选择类名为one的所有元素
- 标签选择器（div），选择标签为div的所有元素
- 后代选择器（#box div），选择id为box元素内部所有的div元素
- 子选择器（.one>one_1），选择父元素为.one的所有.one_1的元素
- 相邻同胞选择器（.one+.two），选择紧接在.one之后的所有.two元素
- 群组选择器（div,p），选择div、p的所有元素



还有一些使用频率相对没那么多的选择器（非常重要）：

- 伪类选择器

```css
:link ：选择未被访问的链接
:visited：选取已被访问的链接
:active：选择活动链接
:hover ：鼠标指针浮动在上面的元素
:focus ：选择具有焦点的
:first-child：父元素的首个子元素
```

- 伪元素选择器

```css
:first-letter ：用于选取指定选择器的首字母
:first-line ：选取指定选择器的首行
:before : 选择器在被选元素的内容前面插入内容
:after : 选择器在被选元素的内容后面插入内容
```

- 属性选择器

```css
[attribute] 选择带有attribute属性的元素
[attribute=value] 选择所有使用attribute=value的元素
[attribute~=value] 选择attribute属性包含value的元素
[attribute|=value]：选择attribute属性以value开头的元素
```



### 优先级

> 内联 > ID选择器 > 类选择器 > 标签选择器

到具体的计算层⾯，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：

- 如果存在内联样式，那么 A = 1, 否则 A = 0
- B的值等于 ID选择器出现的次数
- C的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数
- D 的值等于 标签选择器 和 伪元素 出现的总次数



例子：

```css
#nav-global > ul > li > a.nav-link
```



套用上面的算法，依次求出 `A` `B` `C` `D` 的值：

- 因为没有内联样式 ，所以 A = 0
- ID选择器总共出现了1次， B = 1
- 类选择器出现了1次， 属性选择器出现了0次，伪类选择器出现0次，所以 C = (1 + 0 + 0) = 1
- 标签选择器出现了3次， 伪元素出现了0次，所以 D = (3 + 0) = 3

上面算出的`A` 、 `B`、`C`、`D` 可以简记作：`(0, 1, 1, 3)`



知道了优先级是如何计算之后，就来看看比较规则：

- 从左往右依次进行比较 ，较大者优先级更高
- 如果相等，则继续往右移动一位进行比较
- 如果4位全部相等，则后面的会覆盖前面的

经过上面的优先级计算规则，我们知道内联样式的优先级最高，如果外部样式需要覆盖内联样式，就需要使用`!important`



### flex

关于`flex`常用的属性，我们可以划分为容器属性和容器成员属性

#### 容器属性有：

- flex-direction
- flex-wrap
- flex-flow
- justify-content
- align-items
- align-content



**flex-direction**

决定主轴的方向(即项目的排列方向)

```css
.container {   
    flex-direction: row | row-reverse | column | column-reverse;  
} 
```

属性对应如下：

- row（默认值）：主轴为水平方向，起点在左端
- row-reverse：主轴为水平方向，起点在右端
- column：主轴为垂直方向，起点在上沿。
- column-reverse：主轴为垂直方向，起点在下沿



**flex-wrap**

弹性元素永远沿主轴排列，那么如果主轴排不下，通过`flex-wrap`决定容器内项目是否可换行

```css
Qio;.container {  
    flex-wrap: nowrap | wrap | wrap-reverse;
}  
```

属性对应如下：

- nowrap（默认值）：不换行
- wrap：换行，第一行在下方
- wrap-reverse：换行，第一行在上方

默认情况是不换行，但这里也不会任由元素直接溢出容器，会涉及到元素的弹性伸缩



**flex-flow**

是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap`

```css
.box {
  flex-flow: <flex-direction> || <flex-wrap>;
}
```



**justify-content**

定义了项目在主轴上的对齐方式

```css
.box {
    justify-content: flex-start | flex-end | center | space-between | space-around;
}
```

属性对应如下：

- flex-start（默认值）：左对齐
- flex-end：右对齐
- center：居中
- space-between：两端对齐，项目之间的间隔都相等
- space-around：两个项目两侧间隔相等



 **align-items**

定义项目在交叉轴上如何对齐

```css
.box {
  align-items: flex-start | flex-end | center | baseline | stretch;
}
```

属性对应如下：

- flex-start：交叉轴的起点对齐
- flex-end：交叉轴的终点对齐
- center：交叉轴的中点对齐
- baseline: 项目的第一行文字的基线对齐
- stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度



**align-content**

定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用

```css
.box {
    align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}
```

属性对应如吓：

- flex-start：与交叉轴的起点对齐
- flex-end：与交叉轴的终点对齐
- center：与交叉轴的中点对齐
- space-between：与交叉轴两端对齐，轴线之间的间隔平均分布
- space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍
- stretch（默认值）：轴线占满整个交叉轴



#### 容器成员属性如下：

- `order`
- `flex-grow`
- `flex-shrink`
- `flex-basis`
- `flex`
- `align-self`



**order**

定义项目的排列顺序。数值越小，排列越靠前，默认为0

```css
.item {
    order: <integer>;
}
```



**flex-grow**

上面讲到当容器设为`flex-wrap: nowrap;`不换行的时候，容器宽度有不够分的情况，弹性元素会根据`flex-grow`来决定

定义项目的放大比例（容器宽度>元素总宽度时如何伸展）

默认为`0`，即如果存在剩余空间，也不放大

```css
.item {
    flex-grow: <number>;
}
```

如果所有项目的`flex-grow`属性都为1，则它们将等分剩余空间（如果有的话）

如果一个项目的`flex-grow`属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍



**flex-shrink**

定义了项目的缩小比例（容器宽度<元素总宽度时如何收缩），默认为1，即如果空间不足，该项目将缩小

```css
.item {
    flex-shrink: <number>; /* default 1 */
}
```

如果所有项目的`flex-shrink`属性都为1，当空间不足时，都将等比例缩小

如果一个项目的`flex-shrink`属性为0，其他项目都为1，则空间不足时，前者不缩小

在容器宽度有剩余时，`flex-shrink`也是不会生效的



**flex-basis**

设置的是元素在主轴上的初始尺寸，所谓的初始尺寸就是元素在`flex-grow`和`flex-shrink`生效前的尺寸

浏览器根据这个属性，计算主轴是否有多余空间，默认值为`auto`，即项目的本来大小，如设置了`width`则元素尺寸由`width/height`决定（主轴方向），没有设置则由内容决定

```css
.item {
   flex-basis: <length> | auto; /* default auto */
}
```

当设置为0的是，会根据内容撑开

它可以设为跟`width`或`height`属性一样的值（比如350px），则项目将占据固定空间



**flex**

`flex`属性是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto`，也是比较难懂的一个复合属性

```css
.item {
  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
}
```

一些属性有：

- flex: 1 = flex: 1 1 0%
- flex: 2 = flex: 2 1 0%
- flex: auto = flex: 1 1 auto
- flex: none = flex: 0 0 auto，常用于固定尺寸不伸缩

`flex:1` 和 `flex:auto` 的区别，可以归结于`flex-basis:0`和`flex-basis:auto`的区别

当设置为0时（绝对弹性元素），此时相当于告诉`flex-grow`和`flex-shrink`在伸缩的时候不需要考虑我的尺寸

当设置为`auto`时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑

注意：建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值



**align-self**

允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性

默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`

```css
.item {
    align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
```



###  px em rem 这三中长度单位的区别？

px是一个绝对单位;em和rem是一个相对单位, em参考的是当前元素的字符大写, 参考的是页面根元素html的字体大小。



## JS

### 箭头函数的this

箭头函数可以使函数内部的this指向和函数外部保持一致; 箭头函数之所以可以让函数内部的this指向和外部保持一致是因为箭头函数内部没有this指向. 可以在ajax的回调函数中使用箭头函数让回调函数中的this指向事件源; 可以在定时器的第二个参数中使用箭头函数, 避免函数内部的this指向全局window。



### 同步任务和异步任务

为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制。于是，JS 中出现了**同步任务**和**异步任务**。

***\*同步\****：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务

***\*异步\****：不进入主线程、而进入”任务队列”的任务，当主线程中的任务运行完了，才会从”任务队列”取出异步任务放入主线程执行。



### 节点操作

  1.创建节点

​	createElement // 创建多个元素效率稍低一点点，但是结构更清晰

2. 添加节点

​    var ul = document.querySelector('ul');

​    ul.appendChild(li);//添加到末尾

​    ul.insertBefore(li);//添加到前面

3. 删除节点 ,返回删除的节点  node.removeChild(child)

4. 复制节点  node.cloneNode()

​	//括号参数为空或flase，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点

​	//括号参数为空或true，则是深拷贝，会复制节点本身以及里面的所有子节点

5. 替换节点 ，并返回被替换掉的节点 parentNode.replaceChild(newChild, oldChild); 



### 自定义属性操作

1. setAttribute：设置dom的属性值

2. getAttribute：得到dom的属性值， element.getAttribute('属性')；

3. removeAttribute移除属性

4． ***\*H5自定义属性\****

自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。

H5规定自定义属性data-开头作为属性名并赋值。

dataset 是一个集合，里面存放了所有以data开头的自定义属性

H5新增：element.dataset.index

​	  element.dataset['index']

 // 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法



### 获取页面元素

1. DOM提供的API 方法：  getElementById（id）、getElementsByTagName('标签名') 古老用法 不太推荐 

2. H5提供的新方法： querySelector('选择器'), 返回第一个元素对象

​          	querySelectorAll  根据指定选择器返回元素对象集合, 提倡

  			  里面的选择器需要加符号。 比如： document.querySelector('#nav')；

3. 利用节点操作获取元素： 父(parentNode)、子(children)、兄( previousElementSibling)、弟（nextElementSibling)  提倡

​    firstElementChild（） //第一个子节点  lastElementChild（ie9支持）//最后一个子节点

   	 children[0]  实际开发的写法 //解决兼容性问题中间加Element是ie9支持   

4. 获取特殊元素：document.body  //获取body元素对象,  document.documentElement  //获取html元素对象



## Vue

###  路由传参

1. 使用$router.push 拼接参数传参（面刷新数据不会丢失）

  this.$router.push('/editCardetail?editType=add')

2. 使用name来确定匹配的路由，通过params来传递参数

（页面刷新数据会丢失）

this.$router.push({

​     name: 'editCardetail',

​			params: {

​			     editType: add

​			}

  })

3. 使用path来匹配路由，然后通过query来传递参数



### Vue路由导航守卫是什么, 以及应用场景

路由守卫是在页面进行路由跳转的时候做一些处理, 比如拦截.

Vue-router中提供了下面几种路由导航守卫:

全局前置守卫

```js
const router = new VueRouter({ ... })

router.beforeEach((to, from, next) => {
// from从里来
// to到哪里去
// next是否要放行
})	
```



###  Vue中有何优化页面的加载效率?

使用路由懒加载; 不要打包一些公共的依赖(vue, 组件库), 使用CDN加载这些依赖文件



### 什么是原型对象?

每一个构造函数都有一个prototype的属性, 这个属性的值是一个对象, 这个对象就叫做构造函数的原型对象;

 

### 什么是原型链?

每个构造函数都有一个prototype属性, 即原型对象, 通过实例对象的___proto___属性也可访问原型到对象;而原型对象本质也是一个对象, 是对象就有自己的原型对象, 最终形成的链状的结构称为原型链.



### 什么是构造函数?

构造函数本质也是一个函数,首字母一般需要大写;通过new关键字来调用; 

我们一般不直接使用构造函数, 而是使用构造函数创建出来的实例对象. 构造函数是js面向对象的一个重要组成部分.



## Echarts

### ECharts如何画图

第一，ECharts是通过canvas来实现的，由于canvas的限制，所以echarts在实现的时候多是绘制一些规则的，可预期的，易于实现的东西

第二，echarts的核心就是options配置的对象。一般使用最多的是直角坐标图，极点图，饼状图，地图。

第三，对于直角坐标，必须配置xAsix和yAxis，对于几点坐标必须配置radiusAxis和angleAxis。

第四就是series系列的认识，它是一个数组，数组的每一项都代表着一个单独的系列，可以配置各种图形等等功能。然后data

一般是一个每一项都是数组的数组，也就是嵌套数组。里层数组一般代表坐标位置



### echarts的基本用法

1. 初始化类

> Html里面创建一个id为box1的div，并初始化echarts绘图实例 `var myChart = echarts.init(document.getElementById('box1'))`

1. 样式配置

- title ：标题
- tooltip ：鼠标悬停气泡
- xAxis : 配置横轴类别，type类型为category类别
- series：销量数据，data参数与横轴一一对应，如果想调样式，也可以简单调整，比如每个条形图的颜色可以通过函数进行数组返回渲染

1. 渲染图展示表

> ```
> myChart.setOption(option);
> ```



## 微信小程序

### 小程序有几个文件？

`WXML`： 微信自己定义的一套组件

 `WXSS` :    用于描述 `WXML` 的组件样式

 `js` :   逻辑处理

 `json`  :  小程序页面配置



### 小程序 `WXSS`  与 `CSS` 的区别

`wxss` 背景图片只能引入外链，不能使用本地图片 小程序样式使用 `@import` 引入 外联样式文件，地址为相对路径。



### 小程序的双向绑定和Vue哪里不一样。

小程序 直接使用`this.data.key = value`  是  不能更新到视图当中的。

必须使用  `this.setData({  key ： value  })`  来更新值。 尺寸单位为  `rpx` , `rpx` 是响应式像素,可以根据屏幕宽度进行自适应。



### `app.json`  全局配置文件描述

> `pages`  :  用于存放当前小程序的所有页面路径 `window` : 小程序所有页面的顶部背景颜色，文字颜色配置。 `tabBar`  :  小程序底部的`Tab` ,最多5个，最少2个。



## Uniapp

### vue,小程序,uni-app的生命周期

vue：
	beforeCreate（创建前）
	created（创建后）
	beforeMount(载入前),（挂载）
	mounted（载入后）
	beforeUpdate（更新前）
	updated（更新后）
	beforeDestroy（销毁前）
	destroyed（销毁后）
小程序,uni-app： 
	1. onLoad：首次进入页面加载时触发，可以在 onLoad 的参数中获取打开当前页面路径中的参数。
	2. onShow：加载完成后、后台切到前台或重新进入页面时触发
	3. onReady：页面首次渲染完成时触发
	4. onHide：从前台切到后台或进入其他页面触发
	5. onUnload：页面卸载时触发
	6. onPullDownRefresh：监听用户下拉动作
	7. onReachBottom：页面上拉触底事件的处理函数
	8. onShareAppMessage：用户点击右上角转发



### 跨端会造成功能受限制吗？

uni-app在跨平台的过程中，不牺牲平台特色，不限制平台的能力使用。

应用开发中，80%的常规开发，比如界面组件、联网等api，uni-app封装为可跨多端的API。

其余的，uni-app引入条件编译。可以优雅的在一个项目里调用不同平台的特色能力。比如push，微信小程序里不支持，但可以在App里使用，还有很多原生sdk，在App时难免涉及，这些都可以正常的在uni-app框架下使用。



### 简述 rpx、px、em、rem、%、vh、vw的区别

```javascript
	rpx	相当于把屏幕宽度分为750份，1份就是1rpx
	px	绝对单位，页面按精确像素展示
	em	相对单位，相对于它的父节点字体进行计算
	rem	相对单位，相对根节点html的字体大小来计算
	%	一般来说就是相对于父元素
	vh	视窗高度，1vh等于视窗高度的1%
	vw	视窗宽度，1vw等于视窗宽度的1%
```



# 中级

## CSS

### 选择器

`CSS3`中新增的选择器有如下：

- 层次选择器（p~ul），选择前面有p元素的每个ul元素
- 伪类选择器

```css
:first-of-type 表示一组同级元素中其类型的第一个元素
:last-of-type 表示一组同级元素中其类型的最后一个元素
:only-of-type 表示没有同类型兄弟元素的元素
:only-child 表示没有任何兄弟的元素
:nth-child(n) 根据元素在一组同级中的位置匹配元素
:nth-last-of-type(n) 匹配给定类型的元素，基于它们在一组兄弟元素中的位置，从末尾开始计数
:last-child 表示一组兄弟元素中的最后一个元素
:root 设置HTML文档
:empty 指定空的元素
:enabled 选择可用元素
:disabled 选择被禁用元素
:checked 选择选中的元素
:not(selector) 选择与 <selector> 不匹配的所有元素
```

- 属性选择器

```css
[attribute*=value]：选择attribute属性值包含value的所有元素
[attribute^=value]：选择attribute属性开头为value的所有元素
[attribute$=value]：选择attribute属性结尾为value的所有元素
```



### grid

**介绍一下grid网格布局**

`Grid` 布局即网格布局，是一个二维的布局方式，由纵横相交的两组网格线形成的框架性布局结构，能够同时处理行与列。

擅长将一个页面划分为几个主要区域，以及定义这些区域的大小、位置、层次等关系。



`Grid` 布局属性可以分为两大类：

- 容器属性，
- 项目属性



**display 属性**

元素上设置`display：grid` 或 `display：inline-grid` 来创建一个网格容器

- display：grid 则该容器是一个块级元素
- display: inline-grid 则容器元素为行内元素



**grid-template-columns 属性，grid-template-rows 属性**

`grid-template-columns` 属性设置列宽，`grid-template-rows` 属性设置行高

```css
.wrapper {
  display: grid;
  /*  声明了三列，宽度分别为 200px 200px 200px */
  grid-template-columns: 200px 200px 200px;
  grid-gap: 5px;
  /*  声明了两行，行高分别为 50px 50px  */
  grid-template-rows: 50px 50px;
}
```

以上表示固定列宽为 200px 200px 200px，行高为 50px 50px



`repeat()`函数，可以简写重复的值

- 第一个参数是重复的次数
- 第二个参数是重复的值



上述代码可以简写成

```css
.wrapper {
  display: grid;
  grid-template-columns: repeat(3,200px);
  grid-gap: 5px;
  grid-template-rows:repeat(2,50px);
}
```



除了上述的`repeact`关键字，还有：

- auto-fill：示自动填充，让一行（或者一列）中尽可能的容纳更多的单元格

> `grid-template-columns: repeat(auto-fill, 200px)` 表示列宽是 200 px，但列的数量是不固定的，只要浏览器能够容纳得下，就可以放置元素

- fr：片段，为了方便表示比例关系

> `grid-template-columns: 200px 1fr 2fr` 表示第一个列宽设置为 200px，后面剩余的宽度分为两部分，宽度分别为剩余宽度的 1/3 和 2/3

- minmax：产生一个长度范围，表示长度就在这个范围之中都可以应用到网格项目中。第一个参数就是最小值，第二个参数就是最大值

> ```
> minmax(100px, 1fr)`表示列宽不小于`100px`，不大于`1fr
> ```

- auto：由浏览器自己决定长度

> `grid-template-columns: 100px auto 100px` 表示第一第三列为 100px，中间由浏览器决定长度



**grid-template-areas 属性**

用于定义区域，一个区域由一个或者多个单元格组成

```css
.container {
  display: grid;
  grid-template-columns: 100px 100px 100px;
  grid-template-rows: 100px 100px 100px;
  grid-template-areas: 'a b c'
                       'd e f'
                       'g h i';
}
```



**grid-auto-flow 属性**

划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。

顺序就是由`grid-auto-flow`决定，默认为行，代表"先行后列"，即先填满第一行，再开始放入第二行



**justify-items 属性， align-items 属性， place-items 属性**

`justify-items` 属性设置单元格内容的水平位置（左中右），`align-items` 属性设置单元格的垂直位置（上中下）

两者属性的值完成相同

```css
.container {
  justify-items: start | end | center | stretch;
  align-items: start | end | center | stretch;
}
```



属性对应如下：

- start：对齐单元格的起始边缘
- end：对齐单元格的结束边缘
- center：单元格内部居中
- stretch：拉伸，占满单元格的整个宽度（默认值）

`place-items`属性是`align-items`属性和`justify-items`属性的合并简写形式



**justify-content 属性， align-content 属性， place-content 属性**

`justify-content`属性是整个内容区域在容器里面的水平位置（左中右），`align-content`属性是整个内容区域的垂直位置（上中下）

```css
.container {
  justify-content: start | end | center | stretch | space-around | space-between | space-evenly;
  align-content: start | end | center | stretch | space-around | space-between | space-evenly;  
}
```

两个属性的写法完全相同，都可以取下面这些值：

- start - 对齐容器的起始边框
- end - 对齐容器的结束边框
- center - 容器内部居中

- space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍
- space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔
- space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔
- stretch - 项目大小没有指定时，拉伸占据整个网格容器



**grid-auto-columns 属性和 grid-auto-rows 属性**

有时候，一些项目的指定位置，在现有网格的外部，就会产生显示网格和隐式网格

比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。超出的部分就是隐式网格

而`grid-auto-rows`与`grid-auto-columns`就是专门用于指定隐式网格的宽高



**关于项目属性，有如下：**

grid-column-start 属性、grid-column-end 属性、grid-row-start 属性以及grid-row-end 属性

指定网格项目所在的四个边框，分别定位在哪根网格线，从而指定项目的位置

- grid-column-start 属性：左边框所在的垂直网格线
- grid-column-end 属性：右边框所在的垂直网格线
- grid-row-start 属性：上边框所在的水平网格线
- grid-row-end 属性：下边框所在的水平网格线



**grid-area 属性**

`grid-area` 属性指定项目放在哪一个区域

```css
.item-1 {
  grid-area: e;
}
```



**justify-self 属性、align-self 属性以及 place-self 属性**

`justify-self`属性设置单元格内容的水平位置（左中右），跟`justify-items`属性的用法完全一致，但只作用于单个项目。

`align-self`属性设置单元格内容的垂直位置（上中下），跟`align-items`属性的用法完全一致，也是只作用于单个项目

```css
.item {
  justify-self: start | end | center | stretch;
  align-self: start | end | center | stretch;
}
```

这两个属性都可以取下面四个值。

- start：对齐单元格的起始边缘。
- end：对齐单元格的结束边缘。
- center：单元格内部居中。
- stretch：拉伸，占满单元格的整个宽度（默认值）



### Less和Sass的区别

说说你对这两个的理解

解答：

​	肯定存在差异，如果过这两个基本一样，那肯定是不懂或自以为是。

​	如果能说出Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持就可以。



Sass和Scss有什么区别？

解答：

sass和scss其实是一样的css预处理语言，SCSS 是 Sass 3 引入新的语法，其后缀名是分别为 .sass和.scss两种。
SASS版本3.0之前的后缀名为.sass，而版本3.0之后的后缀名.scss。
两者是有不同的，sass是有严格的**缩进规范**并且**没有**`{ }`和`;`。



会使用mixin吗，Less和Sass使用mixin有何区别？

解答：

​	封装：Less使用@，Scss使用$。

​	调用：Less使用`.`，Scss使用@include。



### call/apply/bind的区别

​		这三个方法都是函数这个特殊对象的方法,通过这三个方法都可以***\*改变函数内部this的指向\****.

​		不同点:

​			call和apply会调用一次函数, 而bind不会调用函数, 只会在内存中创建一个函数的副本(修改过this指向的函数).

​			call从第二个参数开始需要一个参数列表,

​			apply第二个参数需要是一个数组



## JS

### new操作符具体干了什么?

​			第一步创建一个空对象;

​			第二步将this指向空对象;

​			第三步动态给刚创建的对象添加成员属性;

​			第四步隐式返回this



### 节流、防抖

- 节流
  节流的意思是，规定时间内，只触发一次。比如我们设定500ms，在这个时间内，无论点击按钮多少次，它都只会触发一次。具体场景可以是抢购时候，由于有无数人 快速点击按钮，如果每次点击都发送请求，就会给服务器造成巨大的压力，但是我们进行节流后，就会大大减少请求的次数。
- 防抖
  防抖的意思是，在连续的操作中，无论进行了多长时间，只有某一次的操作后在指定的时间内没有再操作，这一次才被判定有效。具体场景可以搜索框输入关键字过程中实时 请求服务器匹配搜索结果，如果不进行处理，那么就是输入框内容一直变化，导致一直发送请求。如果进行防抖处理，结果就是当我们输入内容完成后，一定时间(比如500ms)没有再 输入内容，这时再触发请求。



### js中实现继承的方式?

ES6之前官方并没有提供一种实现继承的语法, 所以大部分继承方式都是程序员通过代码在模拟.常见的继承方式有以下几种:

- 原型继承;

- 借用构造函数继承;

- 组合继承;

```js
function Person(name,age,gender){

this.name=name||'';

this.age=age||'';
Å
this.gender=gender||'';

}

Person.prototype.sayHi=function(){

console.log('I am '+this.name);

}

var p1=new Person('zs',30,'男');

function Student(name,age,gender,score){

// 通过构造继承属性

Person.call(this,name,age,gender);

}

 

// 通过原型继承,继承方法

Student.prototype=new Person();

// 修改constructor的指向

Student.prototype.constructor=Student;

// 动态添加成员方法

Student.prototype.printScore=function(){

console.log('my score is '+this.score);

}

// 创建Student实例对象

var s1=new Student('zs',30,'男',90);

s1.sayHi();

s1.printScore();
```

ES6之后使用extends关键字实现继承



###  什么是闭包, 有什么作用, 使用的时候需要注意什么?

闭包是一个跟函数相关的概念,表现形式是一个父函数内部,嵌套了一个子函数, 子函数直接或间接的被返回给外部作用域, 并且子函数中会使用到父函数局部作用域中的变量.当我们在外部调用这个子函数的时候, 就会发生闭包现象.

闭包的作用:闭包可以延展一个函数的作用域

注意事项:不能滥用闭包, 会导致内存泄漏



### 什么是内存泄漏, 那些操作会引起内存泄漏?

内存泄漏是指本应该被垃圾回收机制回收的内存空间由于某种特殊原因没有及时被回收, 称之为内存泄漏. 滥用全局变量和滥用闭包都会导致内存泄漏



### 什么是预解析?

JS代码在执行之前,解析引擎会对代码进行一个预先的检查,对变量和函数的声明进行提升, 将变量和函数的声明提到代码的最前面.变量只提升声明, 不提升赋值.



### ⭐️如何使用Promise让for循环指定时间选择一次

（下面的所有只相当于Java里的一行代码`Thread.sleep(1000)`）

```js
const sleep = (timeout= 1000)=>new Promise((resolve, reject)=>{
    setTimeout(resolve, timeout);
});
// 可以使用 bluebird模块中的 bluebird.delay() 替换 sleep()
// const bluebird = ruquire('bluebird');
let timer = async(timeout) => {
    for(let i = 0; i< timeout; i++) {
        await sleep(1000);
        console.log(i+1);
    }
}
timer(10);
```



## Vue

### Class 与 Style 如何动态绑定？

Class 可以通过对象语法和数组语法进行动态绑定：

- 对象语法：

```vue
<div v-bind:class="{ active: isActive, 'text-danger': hasError }"></div>

data: {
  isActive: true,
  hasError: false
}
复制代码
```

- 数组语法：

```vue
<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>

data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
```

Style 也可以通过对象语法和数组语法进行动态绑定：

- 对象语法：

```
<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>

data: {
  activeColor: 'red',
  fontSize: 30
}
```

- 数组语法：

```
<div v-bind:style="[styleColor, styleSize]"></div>

data: {
  styleColor: {
     color: 'red'
   },
  styleSize:{
     fontSize:'23px'
  }
}
```



## ⭐️Vue 的父组件和子组件生命周期钩子函数执行顺序？

Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：

- 加载渲染过程

  父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted

- 子组件更新过程

  父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated

- 父组件更新过程

  父 beforeUpdate -> 父 updated

- 销毁过程

  父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed



### computed 和 watch 的区别和运用的场景？

**computed：** 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；

**watch：** 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；

**运用场景：**

- 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；
- 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。



### 简单说下Vuex

Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。

（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。

（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。

主要包括以下几个模块：

- State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。
- Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。
- Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。
- Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。
- Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。



### Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？

一、如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。

二、如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用，并包装成promise返回，在调用处用async await处理返回的数据。如果不要复用这个请求，那么直接写在vue文件里很方便



### Vuex刷新页面数据丢失

- 办法一：将 vuex 中的数据直接保存到浏览器缓存中（sessionStorage、localStorage、cookie）
- 办法二：在页面刷新的时候再次请求远程数据，使之动态更新 vuex 数据
- 办法三：在父页面向后台请求远程数据，并且在页面刷新前将 vuex 的数据先保存至sessionStorage（以防请求数据量过大页面加载时拿不到返回的数据）
  **因为我存取的数据比较少所以通过办法一解决：**
  **在App.vue 中添加以下代码**

```js
//===下面是解决刷新页面丢失vuex数据
  created() {
    //在页面加载时读取sessionStorage里的状态信息
    if (sessionStorage.getItem('store')) {
      this.$store.replaceState(Object.assign({}, this.$store.state, JSON.parse(sessionStorage.getItem('store'))));
    }

    //在页面刷新时将vuex里的信息保存到sessionStorage里
    window.addEventListener('beforeunload', () => {
      sessionStorage.setItem('store', JSON.stringify(this.$store.state));
    });
  }
```



### ⭐️中央事件总线

main.js

```js
Vue.prototype.$bus = new Vue()
```

兄弟组件A.vue

```js
  created () {
    this.$bus.$emit('hello', 'world')
  }
```

兄弟组件B.vue

```js
  created () {
    this.$bus.$on('hello', data => {
      console.log(data)
    })
  }
```



### ⭐️说一说中央事件总线在$on里修改传递的参数会发生什么

（说出三分之二才加分）

> 如果在$on里修改传递的**对象或者数组**，则$emit里会同步修改，也就是说传递的参数实际是一种共用效果，类似Vuex
>
> > 无法修改非对象或者数组

```js
// 兄弟组件A
  data () {
    return {
      // 定义对象或者数组
      testData: {
        t1: 't1'
      }
    }
  },
  onLoad () {
    this.$bus.$emit('test', this.testData)
    setInterval(() => {
      console.log('this.testData', this.testData) // 此时data里的值被 兄弟组件B 修改
    }, 1000)
  },
    
// 兄弟组件B
  created () {
    this.$bus.$on('test', data => {
      data.t1 = 't2' // 修改实参里的值
      console.log(data);
    })
  }
```

```js
// 兄弟组件A
  onLoad () {
    let obj = [{ t1: 't1' }] // 非data里定义
    this.$bus.$emit('test', obj)
    setInterval(() => {
      console.log('this.testData', obj) // 同样修改
    }, 1000)
  },
 
// 兄弟组件B
  created () {
    this.$bus.$on('test', data => {
      data[0].t1 = 't2' // 修改实参里的值
      console.log(data);
    })
  }
```



### ⭐️中央事件总线生命周期

> 界面中引用各个兄弟组件，他们会在同一界面一起加载，当界面离开时会一起销毁。
>
> > 因为离开界面会销毁，所以可以各界面重名。



### 中央事件总线为什么只能是兄弟组件

> 必须在同一界面同时引用的组件才能互相监听，因为离开界面生命周期会执行销毁，所以不能用其他界面。
>
> > 这里的兄弟组件不是同一目录下组件，而是当前界面同时引用的组件，组件在界面中按顺序并列（兄弟）排放。



### ⭐️中央事件总线中$on什么时候会监听事件

> `this.$bus.$on`会一直监听传递来的值，类似于`where (true)`，直到生命周期结束销毁。



## Echarts

### 切换其他组件统计图时，出现卡顿问题如何解决

原因：每一个图例在没有数据的时候它会创建一个定时器去渲染气泡，页面切换后，echarts图例是销毁了，但是这个echarts的实例还在内存当中，同时它的气泡渲染定时器还在运行。这就导致Echarts占用CPU高，导致浏览器卡顿，当数据量比较大时甚至浏览器崩溃

解决方法：在mounted()方法和destroy()方法之间加一个beforeDestroy()方法释放该页面的chart资源，clear()方法则是清空图例数据，不影响图例的resize，而且能够释放内存，切换的时候就很顺畅了

```
beforeDestroy () {
	this.chart.clear()
},
```



## 微信小程序、uniapp

#### 小程序或App端的DOM有什么不一样

解答：无法直接操作DOM，因为web开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应。开发者可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作。   而在小程序中，二者是分开的，分别运行在不同的线程中，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。



## 微信小程序

### `bindtap`  和  `catchtap` 区别

> 相同点：  `都是点击事件`
>
> 不同点：  `bindtap` 不会阻止冒泡，   `catchtap` 可以阻止冒泡。



### 小程序运行机制

> `热启动` ：假如用户已经打开了某个小程序，在一定时间内再次打开小程序的话，这个时候我们就不再需要重新启动了，这需要把我们的后台打开的小程序切换到前台来使用。
>
>  `冷启动`：用户首次打开小程序或被微信主动销毁再次打开的情况，此时小程序需要重新加载启动。



### 小程序有哪些传递数据的方法

> 1. 使用全局变量
>
> 在 `app.js`  中的  `this.globalData = { }`   中放入要存储的数据。 在`组件.js` 中， 头部 引入  `const app = getApp();` 获取到全局变量 直接使用 `app.globalData.key`  来进行赋值和获取值。
>
> 2. 使用 路由
>
> `wx.navigateTo`    和 `wx.redirectTo` 时，可以通过在 `url`  后 拼接 + 变量， 然后在 `目标页面`  通过在  `onLoad` 周期中，通过参数来获取传递过来的值。
>
> 3. 使用本地缓存



### 小程序怎么跟随事件传值

> 在  页面标签上通过 绑定 `dataset-key = value` ， 然后绑定点击通过`e.currentTarget.dataset.key`   来获取标签上绑定的值。

```vue
<button bindtap="get"  data-name="测试"> 拿到传值</button>

get(e){
    console.log(e.currentTarget.dataset.name)
  },
```



## uniapp

### uniapp进行条件编译的两种方法？小程序端和H5的代表值是什么？

```javascript
	通过 #ifdef、#ifndef 的方式
	H5 ： H5
	MP-WEIXIN ： 微信小程序
```



### uniapp上传文件时用到的api是什么？格式是什么？

```js
	uni.uploadFile({
   		url: '要上传的地址',
       		fileType:'image',
        		filePath:'图片路径',
        		name:'文件对应的key',
        		success: function(res){
			console.log(res)
		},
    })
```



### ⭐️uniapp中使用.less或者.scss文件应该存放于哪个目录

应该和App.vue文件同级，就是最外面的那一层，否则在打包上传时此文件无法上传。
